一、23种设计模式分三类：创建性的，结构性的，行为性的

    如何实例化对象？ - >创作模式
    如何撰写对象并更改构图？ - >结构模式
    如何做某事？ - >行为模式

二、创建性：
抽象工厂（Abstract Factory）：创建多个类的实例。提供一个接口，用于创建相关对象或依赖对象的系列，而不指定它们的具体类。

生成器（Builder）：将对象构造与它的表示分离。将复杂对象的构造与其表示分离，以便相同的构造过程可以创建不同的表示。

工厂方法（Factory Method）：创建多个派生类的实例。定义一个用于创建对象的接口，但让子类决定实例化哪个类。工厂方法允许类延迟实例化到子类。

原型（Prototype）：要复制或克隆的完全初始化实例。使用原型实例指定要创建的对象的种类，并通过复制该原型来创建新对象。

单例（Singleton）：只有一个实例才能存在的类。确保一个类只有一个实例，并提供一个全局访问点。

三、结构性：
适配器（Adapter）：匹配不同类的接口。将类的接口转换为另一个客户端期望的接口。适配器让类协同工作，否则会因为接口不兼容而无法工作。

桥接（Bridge）：将对象的接口与其实现分离。将抽象与它的实现解耦，使两者可以独立地变化。

组合（Composite）：简单和复合对象的树形结构。将对象组合成树结构来表示部分整个层次结构。复合材料允许客户端均匀地处理单个对象和对象的组合。

装饰器（Decorator）：动态添加对对象的责任。动态地对对象附加额外的责任。装饰器提供了一种灵活的替代子类来扩展功能。

外观（Facade）：表示整个子系统的单个类。为系统中的一组接口提供统一的接口。FasADE定义了更高级的接口，使子系统更易于使用。

享元模式（Flyweight）：一个细粒度的实例，用于高效共享。使用共享来有效地支持大量细粒度对象。飞锤是一个共享对象，可以同时在多个上下文中使用。在每个上下文中，flyweight充当独立的对象——它与未共享的对象的实例无法区分。

代理（proxy）：表示另一个对象的对象。为另一个对象提供代理或占位符来控制对它的访问。

四、行为性：
责任链（Chain of Resp）：一种在对象链之间传递请求的方法。避免将请求的发送器耦合到它的接收者，通过给不止一个对象一个处理请求的机会。链接接收对象并沿着链传递请求直到对象处理它。

命令（Command）：封装一个命令请求作为一个对象。将请求封装为对象，从而允许用不同的请求、队列或日志请求对客户端进行参数化，并支持可撤销的操作。

解释器（Interpreter）：一种在程序中包含语言元素的方法。给定一种语言，定义其语法的表示以及使用该表示来解释该语言中的句子的解释器。

迭代器（Iterator）：顺序访问集合的元素。提供一种顺序访问聚合对象的元素而不暴露其底层表示的方法。

中介者（Mediator）：定义类之间的简化通信。定义一个对象，该对象封装了一组对象如何交互。中介器通过防止对象彼此显式引用来促进松散耦合，并且它允许您独立地改变它们的交互。

备忘录（Memento）：捕获并恢复对象的内部状态。在不违反封装的情况下，捕获并外部化对象的内部状态，以便稍后可以将对象恢复到此状态。

观察者（Observer）：一种通知更改到多个类的方法。定义对象之间的一对多依赖关系，以便在一个对象改变状态时，自动通知和更新其所有依赖项。

状态（State）：改变对象在状态改变时的行为。允许对象在其内部状态改变时改变其行为。对象将出现改变它的类。

策略（Strategy）：将算法封装在一个类中。定义一系列算法，封装每一个，并使它们可互换。策略使算法独立于使用它的客户端而变化。

模板方法（Template）：将算法的精确步骤推迟到子类。在操作中定义算法的骨架，将一些步骤推迟到子类。模板方法允许子类在不改变算法结构的情况下重新定义算法的某些步骤。

访问者（Visitor）：定义一个新的操作到一个类没有变化。表示要在对象结构的元素上执行的操作。访问者允许您在不改变其操作的元素的类别的情况下定义新操作。